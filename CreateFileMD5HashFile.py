# coding: utf-8
# This file is written by Toxic_Obsidian
# 
# Open source under MIT License.

from hashlib import md5
import os
from sys import argv
import datetime
from progressbar import ProgressBar, Percentage, Bar, ETA, Timer
import codecs
import re

__VERSION__ = '0.2.1 alpha'

muteflag = False
createflag = True

def _removeComment(textline):
    t = textline
    for i in range(len(textline)):
        if textline[i] == '#':
            if i > 0 and textline[i - 1] == '\\':
                continue
            else:
                t = textline[:i]
                break
    return t

def _validFileName(fname):
    p = ''
    for c in fname:
        if c == '#':
            p += '\\'
        p += c
    return p

def _getFileName(vfname):
    p = ''
    i = 0
    while i < len(vfname):
        if vfname[i] == '\\' and vfname[i + 1] == '#':
            p += '#'
            i += 1
        else:
            p += vfname[i]
        i += 1
    return p

# all paths in filelist must be abspaths
def _commonDir(filelist):
    if len(filelist) == 1:
        return os.path.dirname(filelist[0])
    splits = []
    splitter = '/'
    for fpath in filelist:
        if not os.path.isabs(fpath):
            fpath = os.path.abspath(fpath)
        os.path.normpath(fpath)
        if '/' in fpath:
            splits.append(fpath.split('/'))
            splitter = '/'
        elif '\\' in fpath:
            splits.append(fpath.split('\\'))
            splitter = '\\'
        else:
            splits.append([fpath,])


    nMaxSplitPos = len(splits[0]) - 1
    for fsplit in splits:
        r = min(nMaxSplitPos, len(fsplit) - 1)
        i = 0
        while i <= r:
            if splits[0][i] == fsplit[i]:
                i += 1
                continue
            break
        nMaxSplitPos = i - 1


    result = ''
    for i in range(0, nMaxSplitPos + 1):
        if i < len(splits[0]):
            result = result + splits[0][i] + splitter

    return result


def GetFileMD5(filename):
    myhash = md5()
    f = open(filename,'rb')
    t = os.path.getsize(filename)
    r = 0
    last = datetime.datetime.now()
    if not muteflag:
        pbar = ProgressBar(maxval=t, widgets=['Progress: ', Percentage(), ' ', Bar('#'), ' ', ETA(), ' ', Timer()])
    while True:
        b = f.read(8096)
        if not b :
            break
        myhash.update(b)
        r += len(b)
        now = datetime.datetime.now()
        if not muteflag:
            pbar.update(r)
    f.close()
    if not muteflag:
        pbar.finish()
    return myhash.hexdigest()



def WriteMD5File(md5filename, md5vallist, absdatapath = ''):
    md5file = codecs.open(md5filename, 'w', 'utf-8')
    md5file.write('# MD5 checksums generated by Toxic_Obsidian\'s CFMD5HF Utility.\n')
    md5file.write('# Generated at {}\n\n'.format(datetime.datetime.now().strftime('%Y-%m-%d %H-%M-%S')))
    if not absdatapath[-1] == '/' and not absdatapath[-1] == '\\':
        if '/' in absdatapath:
            absdatapath += '/'
        else:
            absdatapath += '\\'
    for csfile, csresult in md5vallist:
        file = csfile
        if not os.path.isabs(file):
            file = os.path.abspath(file)
        md5file.write('{} *{}\n'.format(csresult, _validFileName(file[len(absdatapath):])))
    md5file.close()



def VerifyMD5File(md5filename, rootpath):
    md5file = codecs.open(md5filename, 'r', 'utf-8')
    lines = md5file.readlines()

    md5linepat = re.compile('.*? \*.*')

    matched = []
    mismatched = []
    failed = []
    nCnt = 0
    
    for line in lines:
        res = md5linepat.findall(line)
        if len(res) < 1:
            continue

        nCnt += 1
        res = res[0]
        res = _removeComment(res)
        res = res.strip()               # 去除头尾的多余空格
        splitPos = res.find(' *')
        md5refval = res[:splitPos]      # 更加鲁棒
        csfilename = os.path.normpath(rootpath + '/' + _getFileName(res[splitPos + 2:]))

        if not muteflag:
            print('\nChecking file: {}'.format(_getFileName(res[splitPos + 2:])))
        if os.path.exists(csfilename):
            md5val = GetFileMD5(csfilename)
            if md5val == md5refval:
                matched.append((res[splitPos + 2:], md5val))
            else:
                mismatched.append((res[splitPos + 2:], md5refval, md5val))
        else:
            if not muteflag:
                print('Cannot find file.')
            failed.append(res[splitPos + 2:])

    # matched:      [(file, md5), ...]
    # mismatched:   [(file, doc_md5, calc_md5), ...]
    # failed:       [file, ...]
    return nCnt, matched, mismatched, failed




def ChecksumFiles(filelist):
    result = []
    for idx in range(0, len(filelist)):
        if not os.path.exists(filelist[idx]):
            continue
        filelist[idx] = os.path.abspath(filelist[idx])
    for file in filelist:
        if not os.path.exists(file) or not os.path.isfile(file):
            continue
        if not muteflag:
            print('\nChecking File: {}'.format(file))
        fcsval = GetFileMD5(file)
        md5tuple = (os.path.normpath(file), fcsval)
        result.append(md5tuple)
    return result



def doCheckSum(isPrompt):
    global createflag, muteflag
    filelist = []
    md5filename = ''
    if isPrompt:
        path = input('请输入所要生成MD5值的文件路径或目录：')
        path = os.path.normpath(path)
        if not os.path.exists(path):
            print('无效的路径！（路径不存在）')
            os.system('pause')
            return
        if os.path.isfile(path):
            filelist = [path,]
            md5filename = path + '.md5'
        else:
            while True:
                md5filename = input('请命名所要保存MD5信息的文件（不保存请输入`_no_`）: ')
                if md5filename == '_no_':
                    createflag = False
                try:
                    _tf = open(md5filename, 'w')
                    _tf.close()
                    os.remove(md5filename)
                except:
                    print('MD5文件路径不合法或无写入权限，请重新输入...')
                    continue
                break
            for curDir, dirs, files in os.walk(path):
                for file in files:
                    filelist.append(os.path.join(curDir, file))
    else:
        argc = len(argv)
        for i in range(0, argc):
            if argv[i] == '-p' or argv[i] == '--PATH':
                i += 1
                if i == argc:
                    print('{}: Invalid Syntax!'.format(__file__))
                    return
                path = argv[i]
                if not os.path.exists(path):
                    print('Invalid Parameter! (Path not exist)')
                    return
                if os.path.isfile(path):
                    filelist = [path,]
                else:
                    for curDir, dirs, files in os.walk(path):
                        for file in files:
                            filelist.append(os.path.join(curDir, file))
            elif argv[i] == '-m' or argv[i] == '--MUTE':
                muteflag = True
            elif argv[i] == '-nc' or argv[i] == '--NOT-CREATE':
                createflag = False
            elif argv[i] == '-rf' or argv[i] == '--RESULT-FILE':
                i += 1
                if i == argc:
                    print('{}: Invalid Syntax!'.format(__file__))
                    return
                md5filename = argv[i]
        if createflag and md5filename == '':
            if os.path.isfile(path):
                md5filename = path + '.md5'
            else:
                md5filename = os.path.abspath(path) + '/../result.md5'

    starttime = datetime.datetime.now()
    md5result = ChecksumFiles(filelist)
    endtime = datetime.datetime.now()
    writeflag = True
    while os.path.exists(md5filename):
        ch = input('检测到对应文件的.md5文件，是否覆写？[Y/N]\n')
        if ch == 'N' or ch == 'n':
            writeflag = False
            break
        elif ch == 'Y' or ch == 'y':
            break
        else:
            print('未知命令，请重新输入')
    if createflag and writeflag:
        datapath = _commonDir(filelist)
        WriteMD5File(md5filename, md5result, datapath)
    if not muteflag or (muteflag and not createflag):
        print('Result: \n')
        for f, v in md5result:
            if len(f) > 39:
                print('{:} *{:<39}...\n'.format(v, f))
            else:
                print('{:} *{:<39}\n'.format(v, f))
        if muteflag:
            return
    elif muteflag and createflag:
        print('结果已写入到：{}'.format(md5filename))
        return
    if not muteflag:
        print('运行时间：{:.0f}s'.format((endtime-starttime).seconds))
        if createflag and writeflag:
            print('MD5哈希值已写入' + md5filename)
        else:
            print('根据传入参数，未将结果写入MD5文件')
    os.system('pause')

def doVerify(isPrompt):
    global muteflag
    md5filename = ''
    rootpath = ''
    if isPrompt:
        rootpath = input('请输入校验文件路径或根目录：')
        rootpath = os.path.normpath(rootpath)
        if not os.path.exists(rootpath):
            print('无效的路径！（路径不存在）')
            os.system('pause')
            return
        if os.path.isfile(rootpath):
            filelist = [rootpath,]
            md5filename = rootpath + '.md5'
            ch = input('请输入MD5信息文件路径（默认为{}.md5）:'.format(md5filename))
            if ch != '':
                md5filename = ch
            if not os.path.exists(md5filename) or not os.path.isfile(md5filename):
                print('无效的路径！（路径不存在或路径非文件）')
                os.system('pause')
                return 
        else:
            md5filename = input('请输入MD5信息文件路径: ')
            if not os.path.exists(md5filename) or not os.path.isfile(md5filename):
                print('无效的路径！（路径不存在或路径非文件）')
                os.system('pause')
                return
    else:
        argc = len(argv)
        for i in range(0, argc):
            if argv[i] == '-p' or argv[i] == '--PATH':
                i += 1
                if i == argc:
                    print('{}: Invalid Syntax!'.format(__file__))
                    return
                rootpath = argv[i]
            elif argv[i] == '-m' or argv[i] == '--MUTE':
                muteflag = True
            elif argv[i] == '-v' or argv[i] == '--VERIFY':
                i += 1
                if i == argc:
                    print('{}: Invalid Syntax!'.format(__file__))
                    return
                md5filename = argv[i]
        if md5filename == '':
            if os.path.isfile(path):
                md5filename = path + '.md5'
            else:
                md5filename = os.path.abspath(path) + '/../result.md5'

    starttime = datetime.datetime.now()
    cnt, m, mm, f = VerifyMD5File(md5filename, rootpath)
    endtime = datetime.datetime.now()
    
    print('结论：')
    print('共有 {}/{} 个文件MD5值吻合， {}/{} 个文件MD5值不吻合，{}/{} 个文件无法验证MD5值'.format(len(m), cnt, len(mm), cnt, len(f), cnt))
    if cnt == len(m):
        print('太棒了，看起来文件都一切正常！\n')
    if len(mm) != 0:
        print('\n\nMD5值不吻合的有：')
        print('下列显示为： [文件名]: [参考MD5值]/[计算MD5值]')
        for fn, dv, cv in mm:
            print('{}: {}/{}'.format(fn, dv, cv))
        print('\n\n')
    if len(f) != 0:
        print('\n\n无法计算MD5值的文件有：')
        for fn in f:
            print(fn)
        print('\n这些文件可能已经遗失或被移动到了其他位置\n\n')
    os.system('pause')

if __name__ == '__main__':
        if len(argv) == 1:
            while True:
                os.system('cls')
                print('A Toxic_Obsidian\'s CreateFileMD5HashFile(CFMD5HF) Utility')
                print('Build:\tv' + __VERSION__)
                print('1. 计算文件MD5校核值')
                print('2. 根据.md5文件验证文件完整性')
                print('0. 结束程序')
                ch = input('>>>')

                if ch == '1':
                    doCheckSum(True)
                elif ch == '2':
                    doVerify(True)
                elif ch == '0':
                    quit()
                else:
                    print('未知命令')
                    os.system('pause')
            os.system('pause')
        elif len(argv) == 2:
            if os.path.isabs(argv[1]):
                argv.append('-p')
                argv.append(argv[1])
                argv.append('-nc')
                doCheckSum(False)
        else:
            if not '-p' in argv and not '--PATH' in argv:
                print('{}: You must specify at least one path to check!'.format(__file__))
            elif '-v' in argv or '--VERIFY' in argv:
                doVerify(False)
            else:
                doCheckSum(False)
            
